/**
 * Adapter Types
 *
 * Interfaces for agent and database adapters.
 */

import type { EntityRow, QueryResult, ToolCall } from '../assertions/types.js';
import type { MessageProcessingMetadata } from '../assertions/message-processing.js';

// =============================================================================
// Agent Adapter
// =============================================================================

/**
 * Options for sending a chat message.
 */
export interface ChatOptions {
  /** Message content */
  message: string;
  /** User ID */
  userId: string;
  /** Conversation ID (for continuation) */
  conversationId?: string;
  /** Maximum tool calls before stopping */
  maxToolCalls?: number;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Additional headers */
  headers?: Record<string, string>;
}

/**
 * Token usage from a chat response.
 */
export interface TokenUsage {
  /** Input tokens */
  inputTokens: number;
  /** Output tokens */
  outputTokens: number;
  /** Total tokens */
  totalTokens: number;
}

/**
 * Per-agent usage summary from detailed response.
 */
export interface AgentUsageSummary {
  /** Agent identifier (e.g., 'router-agent', 'tasks-agent') */
  agentId: string;
  /** Input tokens consumed by this agent */
  inputTokens: number;
  /** Output tokens generated by this agent */
  outputTokens: number;
  /** Total tokens for this agent */
  totalTokens: number;
  /** Number of LLM calls by this agent */
  callCount: number;
  /** AI provider (e.g., 'anthropic', 'openai') */
  provider?: string;
  /** Model identifier (e.g., 'claude-haiku-4-5') */
  model?: string;
  /** Token breakdown by category */
  trackedBreakdown?: {
    input: { total: number; byCategory: Record<string, number> };
    output: { total: number; byCategory: Record<string, number> };
  };
}

/**
 * Usage event from the play-by-play trace.
 */
export interface UsageEvent {
  /** Event type */
  type:
    | 'user-input'
    | 'assistant-output'
    | 'tool-call'
    | 'tool-result'
    | 'agent-step'
    | 'sub-agent-input'
    | 'sub-agent-output';
  /** Text content (for user-input, assistant-output, agent-step) */
  text?: string;
  /** Tool name (for tool-call, tool-result) */
  toolName?: string;
  /** Tool input arguments */
  input?: unknown;
  /** Tool output result */
  output?: unknown;
  /** Agent that generated this event */
  agent?: string;
  /** Step number within the agent */
  stepNumber?: number;
  /** Origin: 'history' (prior conversation) or 'current' (this request) */
  origin?: 'history' | 'current';
  /** Timestamp of the event */
  timestamp?: string;
  /** Query sent to sub-agent (for sub-agent-input) */
  query?: string;
}

/**
 * Detailed usage data from agent response.
 * Contains per-agent breakdown, events, and totals.
 */
export interface DetailedUsage {
  /** Per-agent token breakdown */
  agentSummaries?: AgentUsageSummary[];
  /** Play-by-play events trace */
  events?: UsageEvent[];
  /** Aggregated totals */
  totals?: {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
    callCount: number;
    cachedInputTokens?: number;
    cacheCreationTokens?: number;
    cacheReadTokens?: number;
    reasoningTokens?: number;
  };
}

/**
 * Response from the agent.
 */
export interface AgentResponse {
  /** Response text content */
  text: string;
  /** Tool calls made during the response */
  toolCalls: ToolCall[];
  /** Conversation ID */
  conversationId: string;
  /** Correlation ID for tracing (optional, returned by some agents) */
  correlationId?: string;
  /** Token usage (basic) */
  usage?: TokenUsage;
  /** Detailed usage data (per-agent breakdown, events, totals) */
  detailedUsage?: DetailedUsage;
  /** Message processing metadata (condenser, pruner, etc.) */
  messageProcessing?: MessageProcessingMetadata;
  /** Response duration in milliseconds */
  durationMs?: number;
  /** Raw response (for debugging) */
  raw?: unknown;
}

/**
 * Agent adapter interface.
 *
 * Handles communication with the AI agent API.
 */
export interface AgentAdapter {
  /**
   * Send a chat message to the agent.
   */
  chat(options: ChatOptions): Promise<AgentResponse>;

  /**
   * Optional cleanup on shutdown.
   */
  cleanup?(): Promise<void>;
}

// =============================================================================
// Database Adapter
// =============================================================================

/**
 * Entity schema information.
 */
export interface EntitySchema {
  /** Entity name */
  name: string;
  /** Table name in database */
  tableName: string;
  /** Column for title-based lookups */
  titleColumn?: string;
  /** Column for user ID filtering */
  userIdColumn?: string | null;
  /** All column names */
  columns: string[];
}

/**
 * Database adapter interface.
 *
 * Handles database queries and entity management.
 */
export interface DatabaseAdapter {
  /**
   * Find an entity by ID.
   */
  findById(entity: string, id: string): Promise<QueryResult>;

  /**
   * Find an entity by title.
   */
  findByTitle(entity: string, title: string): Promise<QueryResult>;

  /**
   * List entities with optional filters.
   */
  list(entity: string, filters?: Record<string, unknown>): Promise<EntityRow[]>;

  /**
   * Insert a new entity.
   */
  insert(entity: string, data: Record<string, unknown>): Promise<{ id: string }>;

  /**
   * Update an entity by ID.
   */
  update?(entity: string, id: string, data: Record<string, unknown>): Promise<void>;

  /**
   * Delete an entity by ID.
   */
  delete?(entity: string, id: string): Promise<void>;

  /**
   * Get all entity schemas.
   */
  getSchemas(): EntitySchema[];

  /**
   * Get schema for a specific entity.
   */
  getSchema(entity: string): EntitySchema | undefined;

  /**
   * Optional cleanup on shutdown.
   */
  cleanup?(): Promise<void>;
}

// =============================================================================
// Setup Executor
// =============================================================================

/**
 * Result from processing an action.
 */
export interface SetupProcessResult {
  /** Whether the action succeeded */
  success: boolean;
  /** Action status */
  status: string;
  /** Optional message */
  message?: string;
  /** Conversation ID if one was created */
  conversationId?: string;
}

/**
 * Setup executor interface.
 *
 * Handles entity insertion and custom actions during setup.
 */
export interface SetupExecutor {
  /**
   * Insert an entity.
   */
  insert(entity: string, data: Record<string, unknown>): Promise<{ id: string }>;

  /**
   * Process a custom action.
   */
  process?(action: string, id: string): Promise<SetupProcessResult>;
}

// =============================================================================
// Combined Adapter
// =============================================================================

/**
 * Combined adapter providing all capabilities.
 */
export interface CombinedAdapter {
  /** Agent adapter */
  agent: AgentAdapter;
  /** Database adapter */
  database: DatabaseAdapter;
  /** Setup executor */
  setup: SetupExecutor;
  /** Vector store adapter (optional) */
  vectorStore?: VectorStoreAdapter;
  /** Cleanup all adapters */
  cleanup(): Promise<void>;
}

// =============================================================================
// Vector Store Adapter
// =============================================================================

/**
 * Generic Vector Store Adapter
 *
 * Works with any vector database (Milvus, Pinecone, pgvector, etc.)
 * No assumptions about entity types, field names, or filter patterns.
 */
export interface VectorStoreAdapter {
  /**
   * Find a vector record by primary key ID.
   */
  findById(collection: string, id: string): Promise<VectorRecord | null>;

  /**
   * Check if a record exists in the collection.
   */
  exists(collection: string, id: string): Promise<boolean>;

  /**
   * Search by vector similarity.
   * Embedding must be pre-computed (provider-agnostic).
   */
  search(
    collection: string,
    params: {
      /** Pre-computed embedding vector */
      embedding: number[];
      /** Any filters (e.g., { user_id: "xxx" }) */
      filter?: Record<string, unknown>;
      /** Maximum results to return */
      limit?: number;
      /** Which fields to return */
      outputFields?: string[];
    },
  ): Promise<VectorSearchResult[]>;

  /**
   * List available collections.
   */
  listCollections(): Promise<string[]>;

  /**
   * Get schema/fields for a collection (optional).
   */
  getCollectionSchema?(collection: string): Promise<CollectionSchema | null>;

  /**
   * Cleanup resources (optional).
   */
  cleanup?(): Promise<void>;
}

/**
 * Generic vector record - no assumed fields.
 */
export interface VectorRecord {
  /** Record ID */
  id: string;
  /** All fields from the collection */
  fields: Record<string, unknown>;
  /** The embedding vector (optional, may be large) */
  embedding?: number[];
}

/**
 * Generic search result.
 */
export interface VectorSearchResult {
  /** Record ID */
  id: string;
  /** Similarity score */
  similarity: number;
  /** Returned fields based on outputFields */
  fields: Record<string, unknown>;
}

/**
 * Collection schema for introspection.
 */
export interface CollectionSchema {
  /** Collection name */
  name: string;
  /** Field definitions */
  fields: Array<{
    name: string;
    type: string;
    isPrimaryKey?: boolean;
    /** Dimension for vector fields */
    dimension?: number;
  }>;
}
